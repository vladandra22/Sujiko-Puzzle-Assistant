package spa.gui;


import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.List;
import spa.model.Location;
import spa.model.DigitCell;
import spa.model.SujikoGrid;
import spa.model.SumCell;

/**
 * A graphical view on a Sujiko puzzle state.
 *
 */
public class PuzzlePanel extends javax.swing.JPanel {

    /**
     * Creates new form PuzzlePanel.
     */
    public PuzzlePanel() {
        initComponents();
        initPanel();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    /** Cell size in pixels */
    private final int cellSize = 100;
    // TODO: Consider making the cell size changeable by user

   final int offsetX = cellSize; // margin for horizontal coordinates
   final int offsetY = cellSize; // margin for vertical coordinates

   /** The Sujiko puzzle being manipulated */
    private SujikoGrid grid;

    /** Selected cell, affected by keystrokes. */
    private DigitCell selected;

    /**
     * Initializes this panel.
     */
    private void initPanel() {
        setGrid(null);
    }

    /**
     * Sets the puzzle.
     *
     * @param grid  the puzzle
     */
    public void setGrid(final SujikoGrid grid) {
        this.grid = grid;
        this.selected = null;
    }

    /**
     * Gets selected cell.
     *
     * @return the selected cell
     */
    public DigitCell getSelected() {
        return selected;
    }

    /**
     * Sets selected cell.
     *
     * @param cell  the selected cell
     */
    public void setSelected(final DigitCell cell) {
        this.selected = cell;
    }
    
    /**
     * Paints sum values within circles on the specified Graphics object.
     *
     * @param g  The Graphics object on which to paint the sums.
     * @param sumCells  A List of SumCell objects representing the sums to be painted.
     */
    private void paintSums(Graphics g, List<SumCell> sumCells) {
        int radius = 60;
        int circleOffset = radius / 2;
        g.setFont(new Font("Lucida Sans Typewriter", Font.BOLD, 12));

        int k = 0; 
        for (int r = 1; r <= 2; ++r) {
            for (int c = 1; c <= 2; ++c) {
                int x = c * cellSize + offsetX - circleOffset;
                int y = r * cellSize + offsetY - circleOffset;

                // Draw the circle
                g.setColor(Color.WHITE);
                g.fillOval(x, y, radius, radius);
                g.setColor(Color.BLACK);
                g.drawOval(x, y, radius, radius);

                SumCell sum = sumCells.get(k);
                k++;
                if (sum.getSum() != 0) {
                    FontMetrics fm = g.getFontMetrics();
                    int textWidth = fm.stringWidth(sum.toString());
                    int textHeight = fm.getAscent();

                    int textX = x + (radius - textWidth) / 2;
                    int textY = y + (radius - textHeight) / 2 + fm.getAscent();

                    g.drawString(sum.toString(), textX, textY);
                }
            }
        }
    }

    
    /**
     * Draws given cell on given canvas at given location.
     *
     * @param g  Graphics object to draw on
     * @param cell  cell to draw
     * @param x  x-coordinate for bottom left corner of cell
     * @param y  y-coordinate for bottom left corner of cell
     * @param delta_x  x-offset for digit within cell
     * @param delta_y  y-offset for digit within cell
     */
    private void paintCell(final Graphics g, final DigitCell cell,
            final int x, final int y) {
        g.setColor(Color.BLACK);
        g.drawRect(x, y, cellSize, cellSize);

        if(cell == selected) {
            g.setColor(Color.LIGHT_GRAY);
        }
        else {
            g.setColor(Color.WHITE);
        }
        
        g.fillRect(x + 1, y + 1, cellSize - 1, cellSize - 1);
        if (!cell.isEmpty()) {
            Color color = Color.BLACK;
            g.setColor(color);

            FontMetrics fm = g.getFontMetrics();
            int textWidth = fm.stringWidth(cell.toString());
            int textHeight = fm.getAscent();

            int delta_x = x + (cellSize - textWidth) / 2;
            int delta_y = y + (cellSize - textHeight) / 2 + fm.getAscent();

            g.drawString(cell.toString(), delta_x, delta_y);
        }
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(java.awt.Color.DARK_GRAY);
        g.fillRect(0, 0, this.getWidth(), this.getHeight());
        g.setFont(new Font("Lucida Sans Typewriter", Font.BOLD, 24));
        if (grid == null) {
            g.setColor(Color.YELLOW);
            g.drawString("No puzzle loaded", cellSize, cellSize);
            return;
        }
        // puzzle != null
        final int WIDTH = cellSize * 3;
        final int HEIGHT = cellSize * 3;
        // WIDTH, HEIGHT includes top, left border for showing coordinates

        g.setColor(Color.WHITE);
        g.fillRect(cellSize, cellSize, WIDTH, HEIGHT);
        g.setColor(java.awt.Color.BLACK);
        // draw cell background and contents
        for (int r = 0; r != 3; ++ r) {
            final int y = r * cellSize + offsetY;
            for (int c = 0; c != 3; ++ c) {
                final int x = c * cellSize + offsetX;
                // x, y = coordinate of bottom-left corner
                Location location = new Location(r, c);
                final DigitCell cell = grid.getCell(location);
                paintCell(g, cell, x, y);
            }
        }
        paintSums(g, grid.getSumCells());
    }

    /**
     * Returns cell in grid for a given mouse event.
     *
     * @param evt  the mouse event
     * @return  cell in grid at {@code evt}, or {@code null} if non-existent
     * @pre {@code evt != null}
     */
    public DigitCell mouseToCell(final MouseEvent evt) {
        if (grid == null) {
            return null;
        }
        final int row = (evt.getY() - offsetY) / cellSize;
        final int col = (evt.getX() - offsetX) / cellSize;
        if (grid.has(row, col)) {
            Location location = new Location(row, col);
            return grid.getCell(location);
        } else {
            return null;
        }
    }

}
